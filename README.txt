JMScript_Detail - программа для работы с файлами скриптов Apache Jmeter.
Данное приложение позволяет собирать и группировать данные форм (сэмплеров),
а также изменять значение параметров форм для всей группы, где встречается нужный 
параметер формы.

Что нового в этой версии?! 
1. Это все еще отладочная версия, но сейчас процесс доработки подошел в плотную к реализации функционала под нормальные версии
JMX-файлов. 
2. Добавлена скозная нумерация сэмплеров в разрезе контроллера, тредгруппы, тестплана.
3. Добавлена возможность усечения названий сэмплеров. Т.е. если название произведено от ссылки, то отбросится вся часть
до крайнего правого "/" (включительно).
4. Появилась возможность при восстановлении оригинальных названий сэмплеров сохранить преобразованные в выходном JMX-файле.
Тут уже все зависит от предпочтений в конкретной реализации тестового сценария. Т.е. как jmeter будет считать статистику
по сэмплерам. Если сделать скозную нумерацию в разрезе тестплана, то все сэмплеры во всех тредгруппах будут уникальны.
И соответсвенно в итоговом отчете, например, среднее время отклика будет высчитано для каждого сэмплера, не смотрю на то, 
что есть абсолютно одинаковые сэмлеры даже в одном контроллере.
Здесь нужно внимательно выставлять эти признаки, ну или восстановить оригинальные названия сэмплеров.
Хотя jmeter и так должен пронумеровать все после генерации сэмплеров.
Как это работает (этот пункт для основого текста README) -
 a) - признак Сократ. Url в назв... выставляется перед операцией Получить дерево... Так как выполнится процедура усечения названий
      в дереве и следующая логическая операция все запишет в файл с уникальными названиями;
 b) - признак Скозн. нумерац... выставляется перед операцией Сген. колл... На данном этапе происходит обработка дерева на предмет
      одинаковых элементов внутри одного логического блока (например, одинаковых контроллеров внутри другого контроллера). Выбирается
      сущность, в рамках который пронумеруются сэмплеры;
 c) - признак Не восст. ориг... выставляется перед операцией Восст. ориг. имена. Таким образом можно сохранить производные названия
      сэмплеров (!!!котроллеры и тредгруппы при этом вернут прежние названия) в выходном чистовом файле. Если таковой будет генерироваться 
	  в итоге, т.е. важны названия элементов в загружаемом JMX-файле.
 Тут нету рекомендаций по работе с праметрами, все зависит от контекста самого теста. Например, две транзакции перехода на главную 
 страницу в тесте обычно считаются как одна операция, выполненная два раза. В тоже время в jmeter две операции, например, 
 http://host1.org/path1/fetch?numRows=all и http://host1.org/path1/fetch?numRows=topTen видимо будут расценены как одна и та же операция,
 если названия совпадают. Но тут больше похоже на то, что есть две кнопки на странице, которые вызызают один и тот же сервис, но время 
 работы сервиса может существенно отличаться для верхних 10 строк и всех строк, и в свою очередь подразумевается, что не каждой роли
 необходимы все строки из выборки. Т.е. две разные операции с точки зренения бизнес-логики. 
5. Замечена особенность, что на 14" ноутбуке windows 10 немного свободно интерпретирует масштаб отрисовки окон и элементов приложения, 
что бесследно исчезает ряд с кнопками (а именно Запись в файл и Обновление дерева). На 14" linux не тестировалось, но судя по запуску 
на одном и том же ноутбуке на разных ОС, linux ведет себя скромнее с размерами элемнтов приложения. 


Внимание!!! При запуске приложения на другом дистрибутиве linux появилась ошибка при работе с пакетом tix из tkinter.
Сам пакет стандартно есть в tkinter, он импортируется нормально, а tkinter тоже является стандартным пакетом в python.
Это баг самого tix.
Для raspbian (debian) исправилось так:
sudo apt-get install tix-dev.
Под windows 10 запустилось корректно.

Важно!!! Выявлена проблема с версиями XML jmeter. Как оказалось они могут отличаться.
В связи с чем приложение работает только на старых версиях формата JMX, там где использовались node.
Сейчас же используются hashTree и некоторые описания элементов вынесены из тегов в атрибуты.
Под новую версия исправления будут, как только закончится доработка, связанная с уникальностью сэмплеров.
Сейчас очень сырая версия, также хотелось бы добавить некоторые фичи, связанные с сэмлерами.
На такой версии другую существенную правку по всему коду неочень удобно вополнять.

Краткая инструкция:
    
    1. Необходимо указать в переменной setClassDir класса JMScript_Detail актуальный
    путь к каталогу, где находится данный класс.
    
    2. Далее следует перейти в каталог, где лежит данный класс, и запустить приложение 
    инструкцией вида: python runJMScriptDetail.py.
    
    3. В форме необходимо указать путь к каталогу, где находится xml-файл со скриптом (*.jmx)
    
    4. Далее необходимо собрать файлы *.jmx, должен появится список таких файлов.
    
    5. Необходимо указать в поле нужный файл (из списка) для параметризации (можно двойным кликом по файлу из списка).
    
    6. Далее необходимо загрузить (получить) дерево из указанного файла.
    
    7. Нужно указать файл (произвольное название) для сохранения дерева с уникальными названиями 
    ThreadGroup и контроллеров.*
     
    8. Сгенерировать коллекцию с уникальными именами.
    
    9. Выбрать ThreadGroup и аккумулировать рабочую коллекцию.
    
    9.1. Важно! При завершении работы с ThreadGroup обязательно нужно обновить дерево, иначе при переходе к следующей ThreadGroup
    потрутся измениния в предыдущей. Также перед сохранением в файл (после редактирования всех ThreadGroup) необходимо обновить дерево.
    
    10.Далее можно работать с основной (рабочей) коллекцией.

    10.1. Есть возможность автовыбора значения из списка элементов, чекбокс Авто выбор/Все знач. позволяет автозаполнять поля для операций 
    с элементами коллекции. Для этого нужно выбрать этот чексбокс и чекбокс элемента, при нажатии кнопки операции значение подтягивается.
    Внимание! В режиме работы правки элементов данный чексбокс служит для выбора всех элементов или отмены выбора. 
    Т.е. если выполнить операцию Все значения по ключу, то из этого списка ничего не будет подтягиваться, поскольку в данном списке отмечаются элементы для изменения.
    Чтобы не запутаться - в списках, где указывается значения элементов, автовыбор работать не будет, для остальных работает.
    Также если, например, в списке указаны только контроллеры, который не подходит для автозаполнения, то при автозаполнении просто подтянется ключ для этих котроллеров.     
    
    11.При работе с основной коллекцией обновление элементов списка 
    (отмечены чекбоксами в окне) доступно только в двух режимах: 
    "Все знач. по задан. ключу" и "Значен. для кл.-кнтр.-смпл."
    
    12.После того, как все изменения внесены (можно вносить многократно),
    необходимо обновить xml-дерево.
    
    13.Чтобы сохранить измененное дерево с уникальными именами (см. шаг 7),необходимо 
    записать изменения в файл.
    
    14.Чтобы измененное дерево сохранить с оригинальными названиями необходимо указать 
    файл с восстановленными элементами и нажать восстановление оригинальных имен.
    Т.е. нужно указать выходной файл (произвольно, *.jmx, чтобы потом можно было открыть в Jmeter),
    в последствии приложение вернет оригинальные названия котроллеров и ThreadGroup
    
    15.Чтобы начать цикл заново нужно заново получить дерево из указанного файла (см. шаг 6).    

-------
* Jmeter может работать с одинаковыми названиями и котроллеров и групп, чтобы идентифицировать параметр необходимо уникальное название контроллера,
такой механизм предусмотрен в приложении. Для удобства работы можно открыть сгенерированный файл с уникальными названиями в jmeter.