JMScript_Detail - программа для работы с файлами скриптов Apache Jmeter.
Данное приложение позволяет собирать и группировать данные форм (сэмплеров),
а также изменять значение параметров форм для всей группы, где встречается нужный 
параметер формы.

Требования: python 3 и выше.
Ограничения: - некоторые разрешения экранов (проблемы отрисовки формы наблюдались на 14" на windows 10) 
             - При указание пути к рабочему каталогу в windows использовать прямой слеш "/", python не распознает обратные слеши в пути до каталога. 
             - Внимание!!! При запуске приложения на другом дистрибутиве linux появилась ошибка при работе с пакетом tix из tkinter.
             - Сам пакет стандартно есть в tkinter, он импортируется нормально, а tkinter тоже является стандартным пакетом в python.
               Это баг самого tix.
               Для raspbian (debian) исправилось так:
               sudo apt-get install tix-dev.
               Под windows 10 запустилось корректно. 

Что нового в этой версии?!
    1. Небольшие исправления
    2. Данная версия - рабочая бета-версия для стандартных форматов jmx-файлов (hashTree, в старой версии используется node). 
    При работе с нестандартными версиями jmx нужно использовать другую версию приложения (будет выложена в отдельную ветку на github).
    --Выложено отдельным файлом в ветку _old_jmx_, т.е. код брать из основной ветки и заменить файл JMScript_Detail для старой.
    3. Добавлены параметры настройки префиксов и разделителя. См. п.1.

Недавние доработки и пояснения:
    В скором времени ПЛАНИРУЕТСЯ еще добавление некоторого функционала.
    1. Добавлена скозная нумерация сэмплеров в разрезе контроллера, тредгруппы, тестплана.*
    2. Добавлена возможность усечения названий сэмплеров. Т.е. если название произведено от ссылки, то отбросится вся часть
    до крайнего правого "/" (включительно).*
    3. Появилась возможность при восстановлении оригинальных названий сэмплеров сохранить преобразованные в выходном JMX-файле.*
    Тут уже все зависит от предпочтений в конкретной реализации тестового сценария. Т.е. как jmeter будет считать статистику
    по сэмплерам. Если сделать скозную нумерацию в разрезе тестплана, то все сэмплеры во всех тредгруппах будут уникальны.
    И соответсвенно в итоговом отчете, например, среднее время отклика будет высчитано для каждого сэмплера, не смотрю на то, 
    что есть абсолютно одинаковые сэмлеры даже в одном контроллере.
    Здесь нужно внимательно выставлять эти признаки, ну или восстановить оригинальные названия сэмплеров.
    Хотя jmeter и так должен пронумеровать все после генерации сэмплеров.
    Тут нету рекомендаций по работе с праметрами, все зависит от контекста самого теста. Например, две транзакции перехода на главную 
    страницу в тесте обычно считаются как одна операция, выполненная два раза. В тоже время в jmeter две операции, например, 
    http://host1.org/path1/fetch?numRows=all и http://host1.org/path1/fetch?numRows=topTen видимо будут расценены как одна и та же операция,
    если названия совпадают. Но тут больше похоже на то, что есть две кнопки на странице, которые вызызают один и тот же сервис, но время 
    работы сервиса может существенно отличаться для верхних 10 строк и всех строк, и в свою очередь подразумевается, что не каждой роли
    необходимы все строки из выборки. Т.е. две разные операции с точки зренения бизнес-логики. 
    4. Замечена особенность, что на 14" ноутбуке windows 10 немного свободно интерпретирует масштаб отрисовки окон и элементов приложения, 
    что бесследно исчезает ряд с кнопками (а именно Запись в файл и Обновление дерева). На 14" linux не тестировалось, но судя по запуску 
    на одном и том же ноутбуке на разных ОС, linux ведет себя скромнее с размерами элемнтов приложения. 


Краткая инструкция:
    
    1. Необходимо указать в переменной setClassDir класса JMScript_Detail актуальный
    путь к каталогу, где находится данный класс. Также, по желанию, можно изменить символы префикса
    и разделителя перед цифрой (номера элемента), которые добавляются при формировании уникальных имен.
    Важно! Нельзя указывать символ % - он используется для заполнения пробелов в файле дампов.
    
    2. Далее следует перейти в каталог, где лежит данный класс, и запустить приложение 
    инструкцией вида: python runJMScriptDetail.py.
    
    3. В форме необходимо указать путь к каталогу, где находится xml-файл со скриптом (*.jmx)
    
    4. Далее необходимо собрать файлы *.jmx, должен появится список таких файлов.
    
    5. Необходимо указать в поле нужный файл (из списка) для параметризации (можно двойным кликом по файлу из списка).
    
    6. Далее необходимо загрузить (получить) дерево из указанного файла. (При выполнении данного действия можно выбрать опцию*).
    
    7. Нужно указать файл (произвольное название) для сохранения дерева с уникальными названиями 
    ThreadGroup и контроллеров.**
     
    8. Сгенерировать коллекцию с уникальными именами. (При выполнении данного действия можно выбрать опцию*).
    
    9. Выбрать ThreadGroup и аккумулировать рабочую коллекцию.
    
    9.1. Важно! При завершении работы с ThreadGroup обязательно нужно обновить дерево, иначе при переходе к следующей ThreadGroup
    потрутся измениния в предыдущей. Также перед сохранением в файл (после редактирования всех ThreadGroup) необходимо обновить дерево.
    
    10.Далее можно работать с основной (рабочей) коллекцией.

    10.1. Есть возможность автовыбора значения из списка элементов, чекбокс Авто выбор/Все знач. позволяет автозаполнять поля для операций 
    с элементами коллекции. Для этого нужно выбрать этот чексбокс и чекбокс элемента, при нажатии кнопки операции значение подтягивается.
    Внимание! В режиме работы правки элементов данный чексбокс служит для выбора всех элементов или отмены выбора. 
    Т.е. если выполнить операцию Все значения по ключу, то из этого списка ничего не будет подтягиваться, поскольку в данном списке отмечаются элементы для изменения.
    Чтобы не запутаться - в списках, где присутствуют значения элементов, автовыбор работать не будет, для остальных работает.
    Также если, например, в списке указаны только контроллеры, который не подходит для автозаполнения, то при автозаполнении просто подтянется ключ для этих котроллеров.     
    
    11.При работе с основной коллекцией обновление элементов списка 
    (отмечены чекбоксами в окне) доступно только в двух режимах: 
    "Все знач. по задан. ключу" и "Значен. для кл.-кнтр.-смпл."
    
    12.После того, как все изменения внесены (можно вносить многократно),
    необходимо обновить xml-дерево.
    
    13.Чтобы сохранить измененное дерево с уникальными именами (см. шаг 7),необходимо 
    записать изменения в файл.
    
    14.Чтобы измененное дерево сохранить с оригинальными названиями необходимо указать 
    файл с восстановленными элементами и нажать восстановление оригинальных имен.
    Т.е. нужно указать выходной файл (произвольно, *.jmx, чтобы потом можно было открыть в Jmeter),
    в последствии приложение вернет оригинальные названия котроллеров и ThreadGroup. (При выполнении данного действия можно выбрать опцию*).
    
    15.Чтобы начать цикл заново нужно заново получить дерево из указанного файла (см. шаг 6).    

-------
*Как это работает (этот пункт для основого текста README) -
 a) - признак Сократ. Url в назв... выставляется перед операцией Получить дерево... Так как выполнится процедура усечения названий
      в дереве и следующая логическая операция все запишет в файл с уникальными названиями;
 b) - признак Скозн. нумерац... выставляется перед операцией Сген. колл... На данном этапе происходит обработка дерева на предмет
      одинаковых элементов внутри одного логического блока (например, одинаковых контроллеров внутри другого контроллера). Выбирается
      сущность, в рамках который пронумеруются сэмплеры;
 c) - признак Не восст. ориг... выставляется перед операцией Восст. ориг. имена. Таким образом можно сохранить производные названия
      сэмплеров (!!!котроллеры и тредгруппы при этом вернут прежние названия) в выходном чистовом файле. Если таковой будет генерироваться 
	  в итоге, т.е. важны названия элементов в загружаемом JMX-файле.
** Jmeter может работать с одинаковыми названиями и котроллеров и групп, чтобы идентифицировать параметр необходимо уникальное название контроллера,
такой механизм предусмотрен в приложении. Для удобства работы можно открыть сгенерированный файл с уникальными названиями в jmeter.
